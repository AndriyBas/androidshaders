// Frag shader Phong Shading - Per-pixel lighting

precision mediump float;

// texture variables
uniform sampler2D shadowTexture; // depth texture
uniform sampler2D texture1; // color texture


varying float tex;
varying vec2 tCoord;

varying vec3 vNormal;
varying vec3 EyespaceNormal;

// light
uniform vec4 lightPos;
uniform vec4 lightColor;

// shadow projection matrix
uniform mat4 shadowProjMatrix;

// material
uniform vec4 matAmbient;
uniform vec4 matDiffuse;
uniform vec4 matSpecular;
uniform float matShininess;

// eye pos
uniform vec3 eyePos;

// from vertex s
varying vec3 lightDir, eyeVec;

// shadow coordinates
varying vec4 shadowCoord;


 
vec4 texture2DBilinear( sampler2D textureSampler, vec2 uv )
{
	// for bilinear filtering
	float textureSize = 512.0; 		   	//size of the shadow map texture
	float texelSize = 1.0 / textureSize; //size of one texel 

    // in vertex shaders you should use texture2DLod instead of texture2D
    vec4 tl = texture2D(textureSampler, uv);
    vec4 tr = texture2D(textureSampler, uv + vec2(texelSize, 0));
    vec4 bl = texture2D(textureSampler, uv + vec2(0, texelSize));
    vec4 br = texture2D(textureSampler, uv + vec2(texelSize , texelSize));
    return (tl + tr + bl + br)/4.0;
    /*vec2 f = fract( uv.xy * textureSize ); // get the decimal part
    vec4 tA = mix( tl, tr, f.x ); // will interpolate the red dot in the image
    vec4 tB = mix( bl, br, f.x ); // will interpolate the blue dot in the image
    return mix( tA, tB, f.y ); // will interpolate the green dot in the image*/
}

float unpack(vec4 packedZValue)
{
	//const vec4 multCoef = vec4(1.0,1.0/255.0, 1.0/(255.0 * 255.0),1.0/(255.0 * 255.0 * 255.0));
	//return dot(packedZValue,multCoef);
	//return packedZValue.r;
	
	
	vec4 unpackFactors = vec4( 1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0 );
	return dot(packedZValue,unpackFactors);
}

float getShadowFactor(vec4 lightZ)
{

	vec4 packedZValue = texture2D(shadowTexture, lightZ.st);
	float unpackedZValue = unpack(packedZValue);

	//return (packedZValue.x < lightZ.z ? 0.5 : 1.0);
	
	return float(packedZValue.x > lightZ.z);
	//return float(unpackedZValue > lightZ.z);
}


void main() {
	// Just to show them being used
	//vec4 a = lightPos;
    vec4 b = lightColor;
    vec4 c = matAmbient;
    vec4 d = matDiffuse;
    vec4 e = matSpecular;
    vec3 g = eyePos;
    float f = matShininess;
	
	vec3 N = normalize(EyespaceNormal);
    vec3 E = normalize(eyeVec); 
    
    vec3 L = normalize(lightDir);
    
    // Reflect the vector. Use this or reflect(incidentV, N);
    vec3 reflectV = reflect(-L, N);
    
    // Get lighting terms
    vec4 ambientTerm;
   if (tex >= 1.0) {
    	ambientTerm = texture2D(texture1, tCoord);
    }
    else
        ambientTerm = matAmbient * lightColor;
    	
    vec4 diffuseTerm = matDiffuse * max(dot(N, L), 0.0);
    vec4 specularTerm = matSpecular * pow(max(dot(reflectV, E), 0.0), matShininess);
   
   
   	// Shadow
   
   	float sValue = 1.0;
   	//if (shadowCoord.w > 0.0) {
   		vec4 lightZ = shadowCoord / 45.0;// / shadowCoord.w;
		lightZ = (lightZ + 1.0) /2.0;
		lightZ.z += 0.0005;
		sValue = getShadowFactor(lightZ);
		//sValue = distance < lightZ.z ? 0.5 : 1.0;
	//}
   
    gl_FragColor =  (ambientTerm + diffuseTerm + specularTerm) * (sValue) ;
   
   	//gl_FragColor = vec4(depth, depth, depth, 1.0);
   
	//gl_FragColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);//gl_FragDepth;
}